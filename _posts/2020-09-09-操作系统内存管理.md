---
layout:     post
title:      操作系统内存管理
subtitle:   操作系统内存管理简介
date:       2020-09-09
author:     LG
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - 操作系统
    
---



## 操作系统内存管理


### 1. 为什么要有逻辑地址

逻辑地址 指的是程序自身看到的地址空间，它是一个虚拟的地址。逻辑地址需要映射到物理内存，才能完成对内存的操作。那么问题来了，为什么程序操作的时候是虚拟的逻辑地址，而不能直接操作物理地址以及直接对内存的操作。
   
因为程序是写死的，是固定的，而硬件的地址，内存条的地址，是变化的，因为物理内存是可以被占用和释放的，是程序无法知道可用的物理地址，所以必须做出映射。操作系统是多进程的，当前进程操作的地址，可能其它进程也在使用，这样进程就不可以使用这一块地址了。除非是单进程的机器，否则就必须做出逻辑地址与物理地址之间的映射。

### 2. 逻辑地址与物理地址是如何进行映射的

- 固定偏移量

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gnn3icffebj30fa0eodge.jpg)

比如说有俩个程序，程序1的偏移量是0，程序2的偏移量是200，这样，如果程序1 操作的逻辑地址的是100， 那么映射的物理地址就是100. 如果程序2操作的逻辑地址是50，那么映射的物理地址就是250. 这种办法看上去是简单高效，但是其实是存在俩个比较大的问题。


![](https://tva1.sinaimg.cn/large/008eGmZEgy1gnn3ikglzkj30l00f0js9.jpg)
第一：一个程序使用的内存其实是无法进行计算的，随着时间的推移，这个进程使用的内存其实是在不断的进行变化的。这里，我们说程序1使用200的内存，这种说法本来就是不太对的。当然，我们可以说这个程序使用的最大内存说200，那么这个程序在绝大多数时间，使用的内存都是小于200的，那么冗余的内存，就叫做内存碎片。

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gnn3j01hazj30im0cuab1.jpg)
第二：程序运行完毕以后，内存被释放。程序1执行完以后，0-200 这块内存就会被释放出来。如果程序3使用的内存大小是201，刚好比200大一点。这个时候，程序3就无法使用 0-200 这一块内存了。假设很长的一段时间，都没有小于200的内存的程序在运行，那么0-200的内存就会一直被闲置，那么我们把这种内存就叫做外碎片。

- 分页

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gnn3zhswcqj30jq0dqdgk.jpg)
为了减少这些碎片问题，于是提出了一种分页的思想。

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gnn40hxg1hj30kq0d8wfn.jpg)
分页的思想 是将物理内存和逻辑内存都进行切分，分成固定大小的很多片，每一片我们称之为页。为了不混淆，我们将逻辑内存的每一片称为页，物理内存的每一页我们称为帧。这种从页到帧的映射，我们需要一个表记录下来映射关系，这个表我们称之为页表(pageTable)。

页表中存储的最重要的信息是俩个，一个是它的key,也就是它的页号；另外一个是对应的帧号。当然页表存储的不止这俩个内容，还存储了这个页是否可用，当前这一页的读写权限等。

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gnn40m5awoj30li0bgmxy.jpg)
页表是每一个进程都需要维护的。因为进程的这些映射关系都是相互独立的，不可能公用这个映射表。

- 重要的知识点

**1.内存的一个地址里面 “住”的是一个字节(Byte)的数据。**

**2. 32位OS物理地址有2^32个，因而只能使用4GB的内存。**

**3.任何一个32位的程序可操作的逻辑地址是 2^32个，也就是4GB。每个32位的程序都天真的以为自己拥有4GB内存。**

**4. 上面势必造成多个程序使用内存总和大于物理内存，此时会借助磁盘，将并不着急使用的内存先放到磁盘，PT 对应的帧号只是显示磁盘。**


- 看一次内存映射过程

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gnn44uvkxuj30km09sdh0.jpg)

机器： 32位系统，256M内存，也就是 2^28, 页大小为4KB，也就是 4096 个字节

程序：32位程序

逻辑地址 ： 0x000011a3

4K = 12bit，因而：

逻辑地址 32bit = 20bit页号 + 12bit 偏移

物理地址 28bit = 16bit帧号 + 12bit 偏移

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gnn44yrevtj30v60d0dh3.jpg)
按照以上的分析， 00001 是页号， 1a3 是偏移。然后查看页表，假设页号 00001 映射的帧号是 00f3, 然后在对应的帧内找 1a3的偏移，就找到这个地址了。

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gnn40sjy9tj30i20cg407.jpg)
但是如果对应的帧号是磁盘，会发生什么？那么就会发生一个缺页中断，或者是缺页异常，缺页异常，会触发程序进入到内核态。内核需要找到这一帧所对应的数据，然后把它加载到物理内存的帧中，然后把加载好的帧的帧号填写到pagetable的帧号这一栏，进行一个寻址的过程。

我们知道磁盘的数据是加载到内存的帧中，但是如果当前内存的所有帧都满了，那么这个时候磁盘的数据要加载到哪个帧中呢？那么这就涉及到这个页的替换算法。就将帧中最少使用的帧逐出，放到磁盘中，然后把我们当前所需要的数据放到帧中。当然这其中还有很多页的替换算法的，不展开讲了。
所以可以看到磁盘换进了物理内存，不太常用的帧逐出到磁盘，所以，此刻的你应该知道为啥linux下这个从旁部分又叫做swapping了吧。

- 分页小结：

**1. 分页使得每个程序都有很大的逻辑地址空间，通过映射磁盘和高效的置换算法，使得内存 “无限大”。**

**2. 分页使得不同的进程的内存隔离，保证了安全；**

**3. 分页降低了内存碎片问题；**

**4. 但是上述分页过程，需要俩次读内存时间有待优化，页表占用空间较大空间也有待优化。因为页表是存在主存中的，不是存在内存中的。如果我们需要对某一个内存进行访问的话，需要读取俩次内存。先要读取页表，从页表中拿到对应的帧号，然后再拿到帧号去到内存中查询。页表存储在主存中的，其实也是比较占用空间的。**

### 3. 分页中的时间与空间优化
- 时间优化：

将最常访问的几个（一般 8 - 128 个左右）页表项存到访问速度更快的硬件中，一般是在MMU（内存管理单元），这个小表的名称TLB(Translation Lookaside Buffer),可以称其为快表。
寻址先查TLB然后miss后再查PT。快表命中率很高，因为一个事实：程序最常访问的页没几个。
 
- 空间优化：

利用多级页表，多级页表改天单独聊聊这里不展开了，总之可以缩小页表占用的空间。
 

### 4. 程序内部的内存管理 - 分段

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gnn453hdy5j30pi0j6q8f.jpg)
在程序中，我们经常听到堆区，栈区，其实就是分段了。

早期的分段指的是将整个程序分成几个大的内存区域。比如分成4个段。每个段分别对应很多个页，每一段看到的逻辑地址都是从0开始的。分段和分页其实是可以结合的，每个段都有对应的页表的部分。页表可以设置成3项，比如说可以包含段号的，也就是段号，页号，帧号。原来是页号对应帧号，现在是段号 + 页号 对应帧号。这种方式其实效率是比较低的。目前已经被大多数的软件和硬件给抛弃了。完全意义上的分段，现在已经不太存在了。x86-64 这种结构的，都不再使用这种段页结合式的了。这样看来，分段其实已经被抛弃了。但是我们在程序开发中，经常听到段错误。段其实只是保存了逻辑上的意义，在内存管理上已经完全没有意义了。 比如说看一个c语言分段的形式。

如果是一个32位的程序，它的虚拟地址就是4GB。我们分段就是对虚拟地址分成了多个段。首先从低到高，首先最高的1GB空间始终是留给内核的，不同的程序其实是共享这1G的空间的。Text 是存储程序本身的字节码，Data是用来存储程序中静态的变量。然后再往上是堆，堆是往上增长的。然后看栈区，栈区是从高往低增长的。中间有一个Libraries区，也就是函数库区。Libraries区，比如说c语言中常见的是so文件，windows 下常见的dll链接库。还有malloc若申请 > 128K的内存会调用mmap, 在堆和栈之间申请内存。这里的lib区其实是相同位置的。因为它们都是页映射磁盘(mmap就是文件映射内存的系统调用)。

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gnn456yonbj30s00i2wji.jpg)
进程是可以共享这样一段函数库的。共享内存极其常见，例如windows下选择文件的那个对话框。

### 5. CPU 缓存cache 如何起作用

 缓存就是为了缓解CPU和内存之间速度差距。随着计算机的发展，CPU运算速度已经很快了，基本上现在硬件瓶颈的速度不在于CPU，所以在CPU上面设置缓存让CPU可以直接从缓存里面拿，这可以看作几乎没有延迟。基本上越靠近CPU"交互"就读取速度越快，价格越高。

